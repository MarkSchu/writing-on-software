<header>
    <h1>Reading <i>A Philosophy of Software Design</i> - Chapter 1</h1>
    <h2>Understanding, Change, Complexity</h2>
</header>

<p>
    In chapter 1, I took three main points from Ousterhout. Here they are with a few short reflections.
</p>
 
<p>
    First and most important, writing software involves the interplay of three concepts: understanding, change, and complexity. In order to modify a system, the system must be understandable and changeable. Complexity, however, threatens both. Specifically, Ousterhout points out two central relationships between the three concepts: (1) more complexity, less understandability, and (2) more complexity, less changeability. 
</p>

<p>
    This is a really interesting set of concepts and relationships. And I suspect that there are finer grained concepts and relationships. For instance, I imagine that code readability is probably a species of system understandability, and that the more readable something is the less changeable it is. 
</p>

<p>
    Second, Ousterhout identifies two ways to eliminate complexity in software development: (1) write code that is simple and obvious (2) use "modular design" to hide complexity. 
</p>


<p>
    The first strategy seems pretty straightforward. But what does hiding complexity have to do with understanding? I think the kicker here has to do with relevance and attention. As humans, you can only attend to so many things at once. For instance, I can hold, in my attention, the three trees that are right in front of me. I can't, however, attend to every tree in front of me. There are way too many. Modular design is a way to say, "You don't have to pay attention to these things, all you have to do is pay attention to this." 
</p>

<p>
    Third, historically speaking, there have been two main approaches to the design lifecycle: waterfall and agile. Waterfall amounted to a sequence of steps: gather requirements, design, code, test, maintain. Agile, on the other hand, operated according to the following loop: design a small part of the system, implement, discover bugs, fix bugs, repeat. 
</p>

<p>
    What's interesting here is that you can look at both approaches as being on two sides of a spectrum. Waterfall is big picture and linear. Agile is small picture and cyclical. You can wonder what strengths and weaknesses those opposing paradigms and wonder if there is something more in the middle. 
</p>


<p>
    As might expect, there are a number of other interesting and important points made in chapter 1. These three, however, seem to set the tone. I'm very intrigued to see where he takes the relationships between understanding, complexity, and change. 
</p>
