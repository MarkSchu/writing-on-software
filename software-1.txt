(1) There are consumers and providers. 

(2) The main problem with software is that systems are too big to understand. https://www.youtube.com/watch?v=v_nhv6aY1Kg&t=42s

(3) You might ask two questions: 

  1. what is a system 
  2. what does it mean for a person to understand a system? 

(4) Tensengrity. A system held together by the balance of opposing forces. Remove one and the whole thing collapses.https://www.youtube.com/watch?v=esm-1QXtA2Q

(5) Coupling may just be interconnection: I change you, you change me.  Decoupled modules then, are modules that can change without the other changing. However, with modules there are always consumers. And if something is consuming a module, then it is coupled. The existence of a method call - module.foo() - and even an import statement is a consumption. 

(6) Why can't you fully plan out a system? Think about a different system: my garden. Why can't I fully plan out my garden? Because I don't know what's going to to work. I can plant this here and that there, but they might die, or they might grow in a way I didn't intend. At bottom, there are unknowns. I don't know what is going to happen. And many of those are unknown unknowns. 

Another way to look at it is this: there are too many possibilities and many possibilities that you're not aware of. In so far as planning plans against what might happen, its hopeless. 

(7) There are consumers and providers. Consumers have expectations. Providers have implementations. 

(8) Software is a set of decisions. If a single design change requires multiple implementation changes, then you've made the same decision multiple times in the code. 

(9) Suppose you have a website wtih 5 pages. Part of you wants to make the pages different colors and part of you wants to make them the same color. Three strategies: 

  1. hardcode 5 style sheets 
  2. hardcode a single style sheet
  3. use a variable in 5 style sheets that reference a 6th sheet. 

The third options allows for the two kinds of changes. If you want to change all of the page colors at the same time, you change the variable. If you want to give each it's own color, you stop using a varible. 

(10) There are two kinds of consumer: a consumer that you own and a consumer that someone else owns (third party library).

(11) Description of the problem (design & requirements) => decomposition => implementation. 

(12) Is this the progression? 

  user story/problem
  problem decomposition into subtasks
  modules who are responsible for sub tasks 
  requirements of modules
  implementation against requirements

(12) There are consumers and providers. The provider has methods with signatures - foo(str: String, n: Number) - and the consumer invokes those methods. The provider may also have values (variables/constants). A consumer refers to those values. So, in short, a consumer connects to a provider in two tways: 

  1. invocation
  2. reference 

(13) How can you count dependencies? I can think of 3 ways: 

  1. number of modules referenced 
  2. number of methods/values referened 
  3. number of references to method/value

So, the least dependent module possible that is still dependent references a single method/value on a single module, once.

(14) A consuming module always references/consumes another module in its implementation. The closest a reference can get to the interface is as a parameter type in one of its methods.

(15) An module has two external complexities: the complexity of the interface and the complexity of understanding the module's responsbility. 

(16) What's the difference between a module with lots of methods and a function with lots of paramters?

(17) Here's a problem. You have a type interface that's referenced, property for property, in multiple places. If you add or remove those properties, you have to modify every reference to it. 

(18) A computer has 2 possible tasks: storage, transformation. And a computer works like this:

  start with an idea 
  formalize the idea into a representaiton
  store or transform the representation 
  decode the representation back into an idea 